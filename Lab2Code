# Recursive Maze Solver

# Define the maze as a 2D list (0 for open paths, 1 for walls)
# Maze 1 - solvable maze
maze = [
    [1, 0, 1, 1, 1, 1],  # Row 0: Walls and a single open path at (0, 1)
    [1, 0, 0, 0, 0, 1],  # Row 1: Open path between (1, 1) to (1, 4)
    [1, 0, 1, 1, 0, 1],  # Row 2: Some walls and open paths
    [1, 0, 0, 1, 0, 1],  # Row 3: Path goes around a wall at (3, 3)
    [1, 1, 0, 0, 0, 1],  # Row 4: Path towards the bottom-right corner
    [1, 1, 1, 1, 0, 1]   # Row 5: Exit path (5, 4) with walls around it
]
# Maze 2 - wall prevents exit
"""
maze = [
    [1, 0, 1, 1, 1, 1],  # Row 0: Walls and a single open path at (0, 1)
    [1, 0, 0, 0, 0, 1],  # Row 1: Open path between (1, 1) to (1, 4)
    [1, 0, 1, 1, 0, 1],  # Row 2: Some walls and open paths
    [1, 1, 1, 1, 1, 1],  # Row 3: Path goes around a wall at (3, 3)
    [1, 1, 0, 0, 0, 1],  # Row 4: Path towards the bottom-right corner
    [1, 1, 1, 1, 0, 1]   # Row 5: Exit path (5, 4) with walls around it
]
"""
# Maze 3 - spawn is a wall
"""
maze = [
    [1, 0, 1, 1, 1, 1],  # Row 0: Walls and a single open path at (0, 1)
    [1, 1, 0, 0, 0, 1],  # Row 1: Open path between (1, 1) to (1, 4)
    [1, 0, 1, 1, 0, 1],  # Row 2: Some walls and open paths
    [1, 1, 1, 1, 1, 1],  # Row 3: Path goes around a wall at (3, 3)
    [1, 1, 0, 0, 0, 1],  # Row 4: Path towards the bottom-right corner
    [1, 1, 1, 1, 0, 1]   # Row 5: Exit path (5, 4) with walls around it
]
"""
# Maze 4 - end is a wall
"""
maze = [
    [1, 0, 1, 1, 1, 1],  # Row 0: Walls and a single open path at (0, 1)
    [1, 1, 0, 0, 0, 1],  # Row 1: Open path between (1, 1) to (1, 4)
    [1, 0, 1, 1, 0, 1],  # Row 2: Some walls and open paths
    [1, 1, 1, 1, 1, 1],  # Row 3: Path goes around a wall at (3, 3)
    [1, 1, 0, 0, 1, 1],  # Row 4: Path towards the bottom-right corner
    [1, 1, 1, 1, 0, 1]   # Row 5: Exit path (5, 4) with walls around it
]
"""
# Define start and end points (row, col)
start = (1, 1)  # Starting point of the maze
end = (4, 4)    # Exit point (goal) of the maze

# Function to print the maze to the console
def print_maze(maze):
    """
    This function takes the maze as input and prints it row by row.
    Each cell is printed as 1 (wall), 0 (open path), or 2 (part of the solution path).
    """
    for row in maze:
        # For each row, join the values as a string separated by spaces and print
        print(" ".join(str(cell) for cell in row))
    print()  # Adds an extra newline for better readability

# Recursive function to solve the maze
def solve_maze(maze, position, end):
    """
    Recursive function to solve the maze.
    It starts from the 'position' and tries to find a path to the 'end'.
    If a valid path is found, it marks the cells in the path with 2.
    """

    row, col = position  # Unpack the current position into row and column

    # Base case: if we reached the end (goal)
    if position == end:
        maze[row][col] = 2  # Mark the end point as part of the path
        return True          # Return True to indicate that the end has been found

    # 2nd base case: Check if the current position is out of bounds, a wall, or already visited
    if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 0:
        return False  # Return False if out of bounds, a wall (1), or already part of the path (2)

    # Mark the current position as part of the path (using 2 to indicate a path)
    maze[row][col] = 2

    # Recursive exploration of all four directions (up, down, left, right):
    # Move up by decreasing the row (row - 1)
    if solve_maze(maze, (row - 1, col), end):
        return True  # If moving up solves the maze, return True

    # Move down by increasing the row (row + 1)
    if solve_maze(maze, (row + 1, col), end):
        return True  # If moving down solves the maze, return True

    # Move left by decreasing the column (col - 1)
    if solve_maze(maze, (row, col - 1), end):
        return True  # If moving left solves the maze, return True

    # Move right by increasing the column (col + 1)
    if solve_maze(maze, (row, col + 1), end):
        return True  # If moving right solves the maze, return True

    # If no direction works, backtrack and unmark this position (set it back to 0)
    maze[row][col] = 0

    return False  # Return False to indicate that no path was found from this position

# Main function to start solving the maze
def main():
    """
    Main function to initialize the maze-solving process.
    It prints the initial maze, solves it, and then prints the result.
    """

    print("Initial maze:")  # Print the starting state of the maze
    print_maze(maze)        # Call the print_maze function to display it

    # Call the recursive solve_maze function with the start and end points
    if solve_maze(maze, start, end):
        print("Maze solved! Path is marked with 2:")  # If solved, print success message
        print_maze(maze)  # Print the maze again with the solution path marked
    else:
        print("No solution exists for this maze.")  # If no solution, print failure message

# Run the main function when the script is executed
if __name__ == "__main__":
    main()  # Starts the maze-solving process by calling the main function
